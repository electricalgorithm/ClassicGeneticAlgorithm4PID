function [best_result, fitness_of_best, generation_count] = ...
ClassicGeneticAlgorithm(PlantModel, InitialPopulationCount, ReferenceValue, ...
                        EndingCondFFValue, EndingCondGenCount, ...
                        ChanceCrossover, ChanceMutation, ChanceInversion)
% CLASSICGENETICALGORITHM This function uses Classic Genetic Algorithm
% to find best PID coefficients for the given plant model.

    % Limit number for PID to binary conversion.
    LIMIT_NUMBER = 128;

    % Create the initial population, and start the algorithm.
    population = CreateInitialPopulation(InitialPopulationCount);
    sorted_population = ProcessAndSortFitness(population, ...
                                              PlantModel, ...
                                              ReferenceValue);
    % If the generation will be same for EndingCondGenCount generation,
    % exit the program.
    being_same_generation = 0;
    previous_best = sorted_population(:, 1);
    % Count the generation for investigation purposes.
    generation = 1;

    % If the ending condition is not met, continue the process.
    while sorted_population(4, 1) <= EndingCondFFValue && ...
            being_same_generation <= EndingCondGenCount
        
        fprintf('Generation: %d\n', generation);

        % Select best two individuals, put them into the population.
        best_two = [sorted_population(:, 1), sorted_population(:, 2)];
        population(:, [1, 2]) = best_two(1:3, :);

        % Select individuals for crossover, mutation and inversion.
        [group_mas, group_pas] = SelectionMethod(sorted_population, ...
                                                InitialPopulationCount-2);

        % Travel throught to apply mutation, inversion, and crossover.
        for index = 1:size(group_pas, 2)
            % Convert PID values into gens.
            MA_PID_chromosomes = PIDtoBinaryGens(group_mas(1:3, index));
            PA_PID_chromosomes = PIDtoBinaryGens(group_pas(1:3, index));

            % Apply Crossover
            crossovered_chromosome(1, :) = CGA_Crossover( ...
                                           MA_PID_chromosomes(1, :),...
                                           PA_PID_chromosomes(1, :),...
                                           ChanceCrossover ...
                                           );
            crossovered_chromosome(2, :) = CGA_Crossover( ...
                                           MA_PID_chromosomes(2, :),...
                                           PA_PID_chromosomes(2, :),...
                                           ChanceCrossover ...
                                           );
            crossovered_chromosome(3, :) = CGA_Crossover( ...
                                           MA_PID_chromosomes(3, :),...
                                           PA_PID_chromosomes(3, :),...
                                           ChanceCrossover ...
                                           );
            
            % Apply Mutation
            mutated_chromosome(1, :) = CGA_Mutation(...
                                       crossovered_chromosome(1, :),...
                                       ChanceMutation ...
                                       );
            mutated_chromosome(2, :) = CGA_Mutation(...
                                       crossovered_chromosome(2, :),...
                                       ChanceMutation ...
                                       );
            mutated_chromosome(3, :) = CGA_Mutation(...
                                       crossovered_chromosome(3, :),...
                                       ChanceMutation ...
                                       );

            % Apply Inversion
            inverted_chromosome(1, :) = CGA_Inversion( ...
                                        mutated_chromosome(1, :),...
                                        ChanceInversion ...
                                        );
            inverted_chromosome(2, :) = CGA_Inversion( ...
                                        mutated_chromosome(2, :),...
                                        ChanceInversion ...
                                        );
            inverted_chromosome(3, :) = CGA_Inversion( ...
                                        mutated_chromosome(3, :),...
                                        ChanceInversion ...
                                        );

            % Convert binary gens into decimal PID format.
            PID_format = BinaryGenstoPID(inverted_chromosome);
            
            % Check for PID if 0 or LIMIT_NUMBER.
            if PID_format(1) == 0, PID_format(1) = 1; end
            if PID_format(1) == LIMIT_NUMBER, PID_format(1) = LIMIT_NUMBER - 1; end
            if PID_format(2) == 0, PID_format(2) = 1; end
            if PID_format(2) == LIMIT_NUMBER, PID_format(2) = LIMIT_NUMBER - 1; end
            if PID_format(3) == 0, PID_format(3) = 1; end
            if PID_format(3) == LIMIT_NUMBER, PID_format(3) = LIMIT_NUMBER - 1; end

            % Assert into the population.
            population(1:3, index + 2) = PID_format;
        end

        % New generation created after previous for loop.
        generation = generation + 1;

        % Put them into fitness function, and sort the new generation.
        sorted_population = ProcessAndSortFitness(population, ...
                                                  PlantModel, 5);
        
        % If the previous_best is the same as this best, increase
        % the number of being_same_generation.
        if (previous_best(:) == sorted_population(:, 1))
            being_same_generation = being_same_generation + 1;
        else
            % Update the previous best.
            previous_best(:) = sorted_population(:, 1);
        end
    end

    % If the ending condition met, stop the process, and return.
    best_result = sorted_population([1, 2, 3], 1);
    fitness_of_best = sorted_population(4, 1);
    generation_count = generation;

end